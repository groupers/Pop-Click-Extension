<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/js/background.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/js/background.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/** Using background to handle background task which do not require to be processed on each page **/ 
// Initialise. If the database doesn&apos;t exist, it is created

var PopClick_profile = new localStorageDB(&quot;Profile&quot;, chrome.storage.local);
var PopClick_local_clickables = new localStorageDB(&quot;ClickTable&quot;, chrome.storage.local);
var popclickhost = &apos;http://localhost:8000&apos;
var myURL = &quot;about:blank&quot;; // A default url just in case below code doesn&apos;t work
var pageTab = {}
if(PopClick_profile.isNew()) {
	PopClick_profile.createTable(&quot;profile&quot;, [&quot;token&quot;, &quot;privatekey&quot;, &quot;logtime&quot;]);
	PopClick_profile.commit();
	PopClick_profile.createTable(&quot;blocked_websites&quot;,[&quot;web_host&quot;]);
	PopClick_profile.commit();
	PopClick_profile.createTable(&quot;blocked_webpages&quot;,[&quot;web_href&quot;]);
	PopClick_profile.commit();
}
if(PopClick_local_clickables.isNew()) {
	PopClick_local_clickables.createTable(&quot;pageselectable&quot;, [&quot;pagehref&quot;, &quot;elementhref&quot;, &quot;text&quot;, &quot;selector&quot;, &quot;clicks&quot;]);
	PopClick_local_clickables.commit();
}
var profileToken = PopClick_profile.queryAll(&quot;profile&quot;)[0]
var profileAuth = PopClick_profile.queryAll(&quot;profile&quot;)[0]

function validAuthentication(validating){
	if(validating == &quot;Valid&quot;) {
		chrome.browserAction.setPopup({popup: &quot;src/view/popup_control.html&quot;})
	} else if(validating ==&quot;Invalid&quot; ){
		chrome.browserAction.setPopup({popup: &quot;src/view/popup.html&quot;})
	}
}

function checkConnection(){
	profile = PopClick_profile.queryAll(&quot;profile&quot;)[0]
	if(profile &amp;&amp; profile.privatekey &amp;&amp; profile.token){
		fetchValidStatus(popclickhost+&quot;/popclick/api/validprofile/&quot;+profile.token+&quot;/&quot;, profile.privatekey, validAuthentication)
	}
}
checkConnection();

chrome.runtime.onMessage.addListener(function(msg, sender, sendResponse) {
	if(msg) {
		if(msg.getToken) {
			var response = &quot;false&quot;;
			if(typeof profileToken != &apos;undefined&apos;) {
				response = profileToken
			}
			sendResponse(response);
		}
	}
	return true;
});

chrome.runtime.onMessage.addListener(function(msg, sender, sendResponse) {
	if(msg.isBlocked == &quot;webpage&quot;) {
		chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
			var currTab = tabs[0];
			sendResponse((typeof PopClick_profile.queryAll(&quot;blocked_webpages&quot;, {
				query: { web_href: new URL(currTab.url).href }
			})[0] != &quot;undefined&quot;).toString());
		});
		// To deal with asynchronous tasks we must return true;
		return true;
	} else if(msg.isBlocked == &quot;website&quot;) {
		chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
			var currTab = tabs[0];
			sendResponse((typeof PopClick_profile.queryAll(&quot;blocked_websites&quot;, {
				query: { web_host: new URL(currTab.url).hostname }
			})[0] != &quot;undefined&quot;).toString());
		});
		return true;
	}
})

chrome.runtime.onMessage.addListener(function(msg, sender, sendResponse) {
	if(msg) {
		var operation = -1, query = { active: true, currentWindow: true };
		if(msg.block_website) {
			operation = 0;
			chrome.tabs.query(query,function(tabs) {
				var currentTab = tabs[0];
				var url = new URL(currentTab.url)
				blockRequest(url.href, url.hostname, operation)
			});
		} else if(msg.block_webpage) {
			operation = 1;
			chrome.tabs.query(query,function(tabs) {
				var currentTab = tabs[0];
				var url = new URL(currentTab.url)
				blockRequest(url.href, url.hostname, operation)
			});
		}
	} 
});

function isBlockedURI(href, hostname) {
	if(typeof hostname == &apos;undefined&apos;) {
		hostname = &quot;&quot;;
	}
	if(typeof href == &apos;undefined&apos;) {
		href = &quot;&quot;;
	}
	if(href.length &gt; 0) {
		return (0 != PopClick_profile.queryAll(&quot;blocked_webpages&quot;, {
			query: { web_href:href }
		}).length)
	}else if(hostname.length &gt; 0) {
		return (0 != PopClick_profile.queryAll(&quot;blocked_websites&quot;, {
			query: { web_host:hostname }
		}).length)
	}
}
function blockRequest(URI_href, URI_host, operation) {
	console.log(URI_href+&quot; &quot;+URI_host+&quot; &quot;+operation);
	if(operation == 1) {
		var query = PopClick_profile.queryAll(&quot;blocked_webpages&quot;, {
			query: {web_href:URI_href}
		})
		if(0 == query.length) {
			PopClick_profile.insert(&quot;blocked_webpages&quot;, {web_href: URI_href})
		}else {
			PopClick_profile.deleteRows(&quot;blocked_webpages&quot;, {web_href: query[0].web_href});
		}
		PopClick_profile.commit();
		console.log(PopClick_profile.queryAll(&quot;blocked_webpages&quot;, {
			query: {web_href:URI_href}
		}))
	} else if(operation == 0) {
		var query = PopClick_profile.queryAll(&quot;blocked_websites&quot;, {
			query: {web_host:URI_host}
		})
		if( 0 == query.length) {
			PopClick_profile.insert(&quot;blocked_websites&quot;, {web_host: URI_host})
		}else{
			PopClick_profile.deleteRows(&quot;blocked_websites&quot;, {web_host: query[0].web_host});
		}
		PopClick_profile.commit();
		console.log(PopClick_profile.queryAll(&quot;blocked_websites&quot;, {
			query: {web_host:URI_host}
		}))
	}
}

chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) { // onUpdated should fire when the selected tab is changed or a link is clicked 
	chrome.tabs.getSelected(null, function(tab) {
		myURL = tab.url;
			chrome.tabs.sendMessage(tabId, {action: &quot;refresh_dialog&quot;, url: myURL}, function(response) {
			});
			checkConnection()
			var url = new URL(myURL)
			if(!(isBlockedURI(url.href) || isBlockedURI(&apos;&apos;,url.hostname))) {
				chrome.tabs.sendMessage(tabId, {action: &quot;sendpage_info&quot;}, function(response) {
					if(response &amp;&amp; response.objects) {
						var profile_col = PopClick_profile.queryAll(&quot;profile&quot;)[0]
						if(typeof profileToken != &apos;undefined&apos;) {
							postPageObjects(profile_col.token, profile_col.privatekey, response.objects, tabId, myURL)
						}
					}
				});
			}
	});
});

// Since asynchronous task involving Database queries seem to create issues with the message parsing
// A persistent copy of the blocked websites/webpages is hold.


/** Handles profile **/
chrome.runtime.onMessage.addListener(function(msg, sender, sendResponse) {
	var current_time = getLogtime();
	if(msg &amp;&amp; msg.createprofile) {
		var profile = new Array(JSON.parse(msg.createprofile));
		var tok = profile[0][0]
		console.log(tok)
		PopClick_profile.insertOrUpdate(&quot;profile&quot;, {} ,{token: &apos;&apos;+tok, privatekey: &apos;&apos;, logtime: current_time});
		PopClick_profile.commit();
		profileToken = tok;
		sendResponse(&quot;created&quot;);
		return true;
	}
	if(msg &amp;&amp; msg.updateprivate) {
		var priv  = msg.updateprivate
		PopClick_profile.update(&quot;profile&quot;, {}, function(row) { 
			row.privatekey = priv;
			row.logtime = current_time;
			return row;
		});
		PopClick_profile.commit();
	}
});
/** Handles selectable elements **/
chrome.runtime.onMessage.addListener(function(msg, sender, sendResponse) {
	var content, website, pagepath, page, operation, pageobject, sendlogtime, sendclicks = 1;
	if (msg &amp;&amp; msg.sendingevent) {
		content =  new Array(JSON.parse(msg.sendingevent))[0];
		page = &apos;&apos;+content[0];
		var elementhref = &apos;&apos;+content[1];
		var text = &apos;&apos;+content[2];
		var selector = &apos;&apos;+content[3];
		website = &apos;&apos;+content[4];
		pagepath = &apos;&apos;+content[5];

		if(page &amp;&amp; elementhref &amp;&amp; text) {
			var existing_record; 
			if(text === &quot;not-found&quot; || selector === &quot;btnabox-element&quot;) {
				existing_record = PopClick_local_clickables.queryAll(&quot;pageselectable&quot;, {
					query: {elementhref: elementhref, pagehref: page}
				});
			} else {
				existing_record = PopClick_local_clickables.queryAll(&quot;pageselectable&quot;, {
					query: {elementhref: elementhref, pagehref: page, text: text}
				});
			}
			if(typeof existing_record == &apos;undefined&apos; || existing_record.length == 0) {	
				PopClick_local_clickables.insert(&quot;pageselectable&quot;,{ pagehref: page,
					elementhref: elementhref,
					text: text,
					selector: selector,
					clicks: 1});
				operation = &quot;create&quot;;
			} else {

				var current_clicks = existing_record[0].clicks;
				var current_selector = existing_record[0].selector;
				var current_text = existing_record[0].text;
				if(selector === &quot;btnabox-element&quot;) {
					selector = current_selector;
				}
					//Should check for all existing_records. In case we add some later on
					if(text === &quot;not-found&quot; &amp;&amp; existing_record[0].text != &quot;not-found&quot;) {
						text = current_text;
					}
					PopClick_local_clickables.update(&quot;pageselectable&quot;, {  
						pagehref: page,
						elementhref: elementhref,
						text: text,
						selector: selector
					}, function(row) {
						row.clicks = ++current_clicks;
						    // the update callback function returns to the modified record
						    sendclicks = row.clicks;
						    return row;
						});
					operation = &quot;update&quot;;
				}
				PopClick_local_clickables.commit();
				PopClick_profile.update(&quot;profile&quot;, function(row) {
					row.logtime = getLogtime();
					sendlogtime = row.logtime;
				});
				PopClick_profile.commit();
				if(typeof profileToken != &apos;undefined&apos;) {
					postFormatting(website, pagepath, page, elementhref, text, selector, sendclicks, operation, sendlogtime)
				}
			}
		} else if(msg &amp;&amp; msg.sendinginitialisation) {
			content = new Array(JSON.parse(msg.sendinginitialisation));
			var highest_clicks_text = new Array();
			var highest_clicks_href = new Array();
			page = &apos;&apos;+content[0]
		//Top 10 different
		var page_existing_top_ten_elements  = PopClick_local_clickables.queryAll(&quot;pageselectable&quot;, {
			query: {pagehref: page}, sort: [[&quot;ID&quot;,&quot;DESC&quot;], [&quot;clicks&quot;, &quot;DESC&quot;]], distinct: [&quot;elementhref&quot;,&quot;text&quot;]
		});
		for(i = 0 ; i &lt; 10 &amp;&amp; i &lt; (page_existing_top_ten_elements.length); i++) {
			highest_clicks_text[i] = page_existing_top_ten_elements[i].text;
			highest_clicks_href[i] = page_existing_top_ten_elements[i].elementhref;
		}
		highest_clicks_text = JSON.stringify(highest_clicks_text);
		highest_clicks_href = JSON.stringify(highest_clicks_href);
		sendResponse({hc_text: highest_clicks_text, hc_href: highest_clicks_href});
	}
});

function postPageObjects(token, auth, objects, tabID, tabURL) {
	var jsonObj = JSON.stringify({&quot;profile&quot;:auth, &quot;pageobjects&quot;:objects});
	postSendObject(token, jsonObj, &quot;suggestion&quot;, tabID, tabURL, feedback)
}

function feedback(content_feedback, tabID, tabURL) {
	console.log(content_feedback)
	var update = false;
	if(typeof pageTab[tabID] == &apos;undefined&apos;) {
		pageTab[tabID] = tabURL
	} else if(pageTab[tabID] != tabURL) {
		update = true;
		pageTab[tabID] = tabURL
	}
	var numbers = JSON.parse(content_feedback)[&quot;recommendation&quot;].replace(/(\]|\[)/g,&apos;&apos;).split(&apos;,&apos;).map(Number);
	if (isNaN(numbers[0])) {
		numbers = -1;
	}
	chrome.tabs.sendMessage(tabID, {action: &quot;feedback_info&quot;, numbers: numbers, update: update}, function(response) {
	});

}
function postFormatting(website, pagepath, page, elementhref, text, selector, clicks, operation, logtime) {
	var profile_col = PopClick_profile.queryAll(&quot;profile&quot;)[0]
	var profile = [profile_col.privatekey, logtime]
	var pageobject = [page, elementhref, text, selector, website, pagepath]
	var interaction = [operation, clicks]
	var jsonObj = {&quot;profile&quot;:profile, &quot;pageobject&quot;:pageobject, &quot;interaction&quot;:interaction}
	jsonObj = JSON.stringify(jsonObj);
	postSendObject(profile_col.token, jsonObj, &quot;add&quot;,&quot;&quot;,&quot;&quot;, console.log)
}

function postSendObject(token, selectable, task, tabID, tabURL, callback) {
	var postUrl = &quot;none&quot;;
	if (task === &quot;add&quot;) {
		postUrl = popclickhost+&apos;/popclick/api/add/&apos;+token+&apos;/&apos;;
	}else if(task === &quot;suggestion&quot;) {
		postUrl = popclickhost+&apos;/popclick/api/suggestion/&apos;+token+&apos;/&apos;;
	}
    // Set up an asynchronous AJAX POST request
    var xhr = new XMLHttpRequest();
    xhr.open(&apos;POST&apos;, postUrl, true);
    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);
    // Handle request state change events
    xhr.onreadystatechange = function() {
    	if (xhr.readyState == 4) {
    		if (xhr.status == 200) {
    			if (callback) {
    				callback(xhr.responseText, tabID, tabURL);
    			}
    		}
    	}
    };
    xhr.timeout = 5000;
    xhr.send(selectable);

}

function fetchValidStatus(URL, auth, cb) {
	var xhr = new XMLHttpRequest()
	xhr.ontimeout = function() {
		console.error(&apos;Please contact support.&apos;)
	};
	xhr.onload = function () {
		if (xhr.readyState === 4) {
			if (xhr.status === 200) {
				cb(xhr.responseText);
			}
		}
	};
	xhr.open(&apos;POST&apos;, URL, true)
	xhr.send(JSON.stringify({&quot;profile&quot;: auth}))
}
//Add click to collection of clicks
chrome.browserAction.onClicked.addListener(function (tab) {
	chrome.tabs.executeScript(tab.ib, {
		file: &apos;awesomplete.min.js&apos;
	});
});

</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
